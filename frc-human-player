#!/usr/bin/env python3

import json
import os
import os.path
import sys

from frcclient import client
from frcclient.types import levels

cfg = os.environ.get("FRC_APIS_JSON", os.path.expanduser("~/.frc-apis.json"))
udata = {}
if os.path.exists(cfg):
    data = {}
    with open(cfg, "r") as fp:
        data = json.loads(fp.read())
    udata = data.get('auth', {}).get('frc', {})

if udata == {}:
    print("Need to add ~/.frc-apis.json")
    sys.exit(1)


# this just strips off a single top level key in 'data'. It is useful when
# a response to client.get() has a single field, like most frc responses do.
def get_single(data, name="not-given"):
    keys = list(data.keys())
    if len(keys) != 1:
        raise ValueError("data type %s had %d keys: %s", name, len(keys), keys)
    return data[keys[0]]


client = client.client(user=udata['user'], key=udata['key'])

year = "2024"
mylevels = [levels.Quals, levels.Playoff]

result = client.cache(year + "/events")
events = get_single(result, "events")
num_events = len(events)

result = client.cache(year + "/teams")
allteams = {t['teamNumber']:t for t in get_single(result, "teams")}
mics = ['micCenterStage', 'micStageLeft', 'micStageRight']


hplaydata = {}
for team, teamdata in allteams.items():
    hplaydata[team] = {'matches': 0, 'mics': 0, 'spm': 0,
                       'spb': 0,
                       'district': teamdata['districtCode'],
                       'country': teamdata['country'],
                       'name': teamdata['nameShort'].strip(),
                       'state': teamdata['stateProv']}
#import pdb;pdb.set_trace()

#print(f"There are {len(allteams)} teams and {len(events)} events in {year}")

for n, ev in enumerate(events):
    #print(f'{n+1}/{num_events}: Event code {ev["code"]} type={ev["type"]} was ' +
    #      f'week {ev["weekNumber"]} {ev["districtCode"]}/{ev["divisionCode"]}')

    for level in mylevels:
        result = client.cache(f'{year}/scores/{ev["code"]}/{level}')
        scores = get_single(result, "scores")
        scoremn = {s['matchNumber']: s for s in scores}

        result = client.cache(f'{year}/matches/{ev["code"]}', tournamentLevel=level)
        matches = get_single(result, "matches")
        matchmn = {s['matchNumber']: s for s in matches}

        for mnum in sorted(matchmn.keys()):
            if mnum not in matchmn:
                if level != levels.Playoff:
                    print(f'  {ev["districtCode"]}/{level}/{mnum} did not have match')
                continue
            if mnum not in scoremn:
                if level != levels.Playoff:
                    print(f'  {ev["districtCode"]}/{level}/{mnum} did not have score')
                continue
            mmatch = matchmn[mnum]
            mscore = scoremn[mnum]
            red = [t['teamNumber'] for t in mmatch['teams'] if t['station'].startswith("Red")]
            blue = [t['teamNumber'] for t in mmatch['teams'] if t['station'].startswith("Blue")]
            rscores = [s for s in mscore['alliances'] if s['alliance'] == 'Red']
            bscores = [s for s in mscore['alliances'] if s['alliance'] == 'Blue']

            for alliance, mscores in ((red, rscores), (blue, bscores)):
                if len(mscores) == 0:
                    continue
                msc = mscores[0]
                spb = msc['endGameSpotLightBonusPoints']
                miked = [k for k in mics if msc[k]]

                for t in alliance:
                    hplaydata[t]['matches'] = hplaydata[t]['matches'] + 1
                    hplaydata[t]['spb'] = hplaydata[t]['spb'] + spb
                    hplaydata[t]['mics'] = hplaydata[t]['mics'] + len(miked)
                    if spb:
                        hplaydata[t]['spm'] = hplaydata[t]['spm'] + 1

        # endGameSpotLightBonusPoints...
        #import ipdb; ipdb.set_trace()
        #print("   Had %d matches in %s" % (len(matches), level))

hplaydata = {k: v for k, v in hplaydata.items() if v['matches'] != 0}
with open("hplayer.json", "w") as fp:
    fp.write(json.dumps(hplaydata, indent=1))

results = sorted(hplaydata.items(),
                 key=lambda d: (d[1]['spm'] / d[1]['matches'],
                                -d[1]['matches']),
                 reverse=True)

for n, (t, d) in enumerate(results):
    if d['matches'] == 0:
        continue

    rate = d["spm"] / d["matches"]
    #print(f'{n+1:>4d} {t:>4s} {d["matches"]:<3d} {d["spl"]:>2} {rate:%>.3f}')
    print(",".join(
        # 16,180,25,44,22,68,0.324,S.P.A.M.,None,USA,Florida
        str(s) for s in [
            n+1, t,
            d['spb'], d['mics'], d['spm'], d['matches'],
            "%0.3f" % rate,
            "%0.3f" % (d['mics'] / (d['matches'] * 3)),
            d['name'], d['district'], d['country'], d['state'],
        ]))

#import pprint; pprint.pprint(results)
